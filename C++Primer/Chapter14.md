## Chapter 14 重载运算与类型转换

- 重载运算符可以重载成员函数也可以重载非成员函数，但是不能重载内置类型的运算符

- 重载运算符应该继承而非违背内置版本的含义

- 并不是所有的运算符重载都适合定义为成员函数

  ```cpp
  string t = "h" + string("i"); // if operator+ has been declared in class string, this sentence is wrong, but if it is not a member function, it can work correctly.
  ```

- 通常情况下，具有对称性质的运算符例如算术、相等性、关系以及位运算都应该定义为非成员函数。

- 重载输入输出运算符

  -  重载输出运算符<<

    ​	通常情况下，输出运算符的第一个形参是一个非常量 ostream 对象的引用，非常量引用是由于向流写入内容会改变其状态。第二个形参一般是一个常量引用，该常量是想要打印的类类型。operator<<一般需要返回 ostream 形参。

    ​	通常输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符，格式控制的操作应交由用户控制，而运算符本身仅需要负责输出类中的数据成员。

    ​	**输入输出运算符必须是非成员函数**，如果为成员函数则必须也是 IO 库的成员，显然并不能修改标准库的代码，因此这类操作应定义为非成员函数。同时由于 IO 运算符通常需要读取非公有成员，因此也通常声明为友元。

  - 重载输入运算符>>

    输入运算符的定义与输出运算符类似。与输出运算符不同的是，输入运算符需要处理输入可能失败的情况，而输出运算符不需要。
  
- 算术与关系运算符

  ​	算术运算符和关系运算符定义成为非成员函数以允许对左侧和右侧的运算对象进行转换，而形参通常是常量引用（这些运算符不需要改变对象的状态）。

  - 相等运算符

  - 关系运算符

    ​	由于一些容器算法需要使用到小于运算符，定义 operator< 会比较有用。如果类有 == 运算符，< 运算符的逻辑应与其一致，两个 != 的对象应该能判别出它们的大小。并不是所有类都有一个逻辑上的小于，所以并非所有类都适合定义一个小于运算符。

- 赋值运算符

  ​	为了与内置类型的赋值运算符保持一致，自定义的赋值运算符也应该返回左侧运算对象的引用。赋值运算符应该定义在类的内部。

- 下标运算符

​		下标运算符必须是成员函数。下标运算符通常以访问元素的引用作为返回值，并且应定义常量版本和非	常量版本，定义常量版本的意义在于可以控制一个	类的常量对象在下标访问时不会修改其值。

- 递增递减运算符

  ​	迭代器类中通常会实现递增递减运算符，这类运算符也应该定义为成员函数。定义递增递减运算符应同时定义前置版本和后置版本。

  - 前置版本（返回引用）

    ```cpp
    A &operator++();
    A &operator--();
    ```

  - 后置版本（返回原值）

    ```cpp
    A operator++(int);
    A operator--(int);
    A A::operator++(int) {
        auto ret = *this;
        ++*this; // use pre-mode to implement post-mode.
        return;
    }
    ```

    ​	int 形参并不被使用，而是作为区分前后版本的标识。后置版本在实现时需要先记录对象的状态。也可以通过传参来显式调用递增运算符的后置版本。

- 成员访问运算符

  ​	箭头运算符通常将工作委托给解引用运算符。箭头运算符必须是类成员，解引用运算符通常也是类成员。对于包含箭头运算符的表达式来说，运算符的调用对象必须是一个指向类对象的指针或者是一个重载了箭头运算符的类对象。依据对象的不同，箭头运算符分别等价于

  ```cpp
  a->fun; // is equal to two different meaning base on a.
  // 1. (*a).fun;
  // 2. a.operator()->fun;
  ```

  ​	第一种情况比较容易理解，第二种情况下，使用 operator->() 的结果来获取 func，如果这个结果是一个指针则会调用1，如果结果是一个重载了箭头运算符的类则会执行2。因此箭头运算符的返回值必须是类指针或者是自定义了箭头运算符的类对象。

- 函数调用运算符

  ​	类重载了函数调用运算符则可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比更加灵活。函数调用运算符的重载必须是成员函数，一个类可以有多种类型的调用运算符。

  - lambda 是函数对象

    ​	当编写了一个 lambda 表达式，编译器将该表达式翻译成一个未命名类的未命名对象，并在类中重载一个函数调用运算符

  - 标准库定义的函数对象

    ​	标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，表示运算符的函数对象类常用来代替算法中的默认运算符，例如默认情况下，排序算法使用 operator< 将序列按照升序排列，如果想要降序排列可以传入一个 greater 类型对象按降序排列。
    
    ```cpp
    sort(svec.begin(), svec.end(), greater<string>());
    ```
    
    ​	指针的 operator< 行为是未定义的，但是标准库的 less 对于指针则是定义良好的。

- 可调用对象与 function

  ​	C++语言中的可调用对象有：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类。
  
  ​	function 定义在 functional 头文件中，function 对象在创建时必须提供能调用的形式。
  
  ​	不能直接将重载函数的名字存入 function 类型的对象中，但是可以通过传入函数指针或者将函数包装成 lambda 表达式实现（推荐方法2）。

- 类型转换运算符

  ​	可以通过定义类型转换运算符来实现类之间的转换。类型转换运算符如下：

  ```cpp
  operator type() const; // type just a symbol of a certain class. In fact, we can define any class except void.
  ```

  ​	类型转换运算符没有没有显式的返回值类型，也没有形参，并且必须定义为类成员函数。类型转换运算符为隐式执行，因此不能传递任何实参。虽然声明时没有显式声明返回值类型，但是每个类型转换运算符都有自身的返回值类型。

  ​	类很少定义类型转换运算符，通常只会定义向 bool 类型的转换。但也会存在误转换的情况，因此通常使用显式类型转换运算符。**定义类型转换运算符需要谨慎以避免产生二义性问题。**

  ```cpp
  explicit operator int() const {}
  ```

  ​	这种定义的类型转换运算符只有在显式使用 static_cast 调用时才会进行转换。但是这种规定也有例外，当用作条件时即使是显式类型转换运算符也会自动隐式转换。

- 函数匹配

  ​	当调用一个普通非成员函数运算符时，无法区分是成员函数版本还是非成员函数版本，要避免二义性。