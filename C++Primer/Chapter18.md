## Chapter 18 用于大型程序的工具

- 异常处理

  - 沿着调用链的函数可能会提早退出
  - 一旦程序开始执行异常处理代码，则沿着调用链创建的对象都将被销毁

- 抛出指向局部对象的的指针是几乎肯定错误的行为

- 如果 throw 表达式解引用一个基类指针，而该指针实际指向派生类，则抛出对象将被切掉一部分，只有基类部分被抛出。

  ```cpp
  class A {
      int a;
  };
  
  class B : public A {
      int b;
  };
  
  int main() {
      try {
          A *a = new B();
          throw *a;
      }
      catch (const B &b) {
          cout << "b" << endl;
      }
      catch (const A &a) {
          cout << "a" << endl;
      }
      catch (...) {
          cout << "c" << endl;
      }
  } // result: a
  ```

- 捕获异常类型必须是完全类型，它可以是左值引用，但不能是右值引用

  > 完整类型是指在编译期，编译器能计算出一个类型的 size。

- throw; 空的 throw 表达式只能出现在 catch 语句或 catch 语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空 throw 语句，编译器将调用 terminate。

  - 一个重新抛出的语句并不指定新的表达式，而是将当前异常对象沿着调用链向上传递。

- 当 catch 语句改变了参数内容并重新抛出，只有在参数类型为引用类型时，改动才会继续传播。

- `catch(...)` 可以捕获所有类型的异常。

- 处理初始值列表抛出的异常

  ```cpp
  class A {
  public:
      A(int a) try : _a(a) {} catch(...){}
  private:
      int _a;
  }
  ```

- noexcept 异常说明

  - 函数指针只能指向具有相同异常说明的函数
  - 虚函数基类如果声明不抛出异常，则派生类不能抛出异常。基类如果声明允许抛出异常，则派生类既可以抛出异常，也可以不抛出异常。