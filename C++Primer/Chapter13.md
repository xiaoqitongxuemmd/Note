## Chapter 13 拷贝控制

- 类中对于对象的拷贝、移动、赋值等操作由以下五类成员函数控制

  - 拷贝构造函数
  - 拷贝赋值运算符
  - 移动构造函数
  - 移动赋值运算符
  - 析构函数

- 拷贝构造函数

  拷贝构造函数通常不应该是 explicit，并且型参类型为 const 引用。

  ```cpp
  class A {
      A ();
      A (const A &); // copy constructor.
  }
  ```

  与默认构造函数不同，即使在定义了拷贝构造函数，编译器也会合成一个构造函数。

- 重载赋值运算符

  ```cpp
  class A {
      A &operator=(const A &); // overload operator =
  }
  ```

- 一个类如果需要定义析构函数，几乎也需要定义拷贝构造与拷贝赋值运算。

- 使用 = default 来显示声明要求编译器提供合成版本构造函数。

- 使用 = delete 来阻止某种类型的函数，可以理解为这种类型的操作被删除，编译器也不会提供合成版本。将该函数私有化可以达到类似目的。

- 定义拷贝赋值运算符时需要考虑自己赋值给自己的情况，通常需要对被赋值对象进行拷贝，释放原对象并将拷贝赋值来完成。

  ```cpp
  A &operator=(const A &rhs) {
      auto new_ps =  new string(*rhs.ps); // ps is a member of class A.
      delete ps; // free current ps.
      ps = new_ps;
      return *this;
  }
  ```

  赋值运算符需要满足的两点要求：

  - 将一个对象赋予自身可以正常工作
  - 大多数赋值运算符整合了构造函数与析构函数

- 通过引用计数来控制行为像指针的类，可以通过动态内存来实现引用计数。在构造函数中，申请引用计数的内存，拷贝赋值运算符中共享引用计数并递增。

- 管理资源的类除了定义拷贝控制，还定义一个名为 swap 函数。

  ```cpp
  class A {
      friend void swap(A &lhs, A &rhs);
  private:
      string *ps;
  }
  inline void swap(A &lhs, A &rhs) {
      using std::swap;
      swap(lhs.ps, rhs.ps);
  }
  ```

  上例中使用了 using std::swap，因为 swap的调用应该是未加限定的，如果又匹配程度更高的 swap 则不会优先调用 std 的版本。
  
- 在定义 swap 的类中通常可以以如下方式定义赋值运算符，使用**拷贝并交换**技术，保证了自赋值的正确性。

  ```cpp
  A& A::operator=(A a) { // the parameter do not use reference.
      swap(*this, rhs);
      return *this;
  }
  ```

- 动态内存管理类

  allocator分配的内存是未构造的（new 申请的内存会进行构造，因此造成了性能的下降）。

  - allocate <--> deallocate
  - construct <--> destroy

- 进行 reallocate 时可以考虑避免分配和释放的额外开销。

- 使用移动的一个原因是例如 IO 类和 unique_ptr 这样的类并不包含可共享的资源，这种对象不能拷贝但可以移动。

- 左值持久，右值短暂，左值有持久的状态，右值要么是字面值常量，要么是在表达式求值中创建的临时对象

  - 右值引用对象将要销毁

  - 该对象没有其他用户

- std::move 告诉编译器我们要像右值一样处理传入的值。

- 由于移动操作通常不分配任何资源，因此移动操作通常不会抛出异常，这种需要提前告知编译器，防止其做一些额外的工作。（使用 noexpect），标准库 vector 就保证使用 push_back 在抛出异常时保持原内容不变，这样针对抛出异常和不抛出异常的处理就会有所不同。

- 移动后源对象必须可以正常析构

- 当一个类有拷贝构造函数但未定义移动构造函数，这种情况下编译器不会自动合成移动构造函数，即使是右值也会被拷贝。

- 移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器，其会返回右值引用。使用 make_move_iterator 可以将一个普通迭代器转换为一个移动迭代器。

- 调用 std::move 时必须保证其没有其他用户。

- 旧标准中无法阻止向一个右值赋值，新标准下可以通过添加**引用限定符（&）**来使得赋值运算符左侧的对象是一个左值。引用限定符只能在类中定义的函数来使用，用于控制 this 的行为。如果一个成员函数有引用限定符，则**重载具有相同参数列表**的所有函数都必须有引用限定符。