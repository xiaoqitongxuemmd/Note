## Chapter 3 在线程间共享数据

### 线程间共享数据的问题

---

- 多线程共享数据的问题多由数据改动引发。
- 防止数据恶性竞争最简单的就是采用保护措施包装数据结构，确保不变量被破坏时，中间状态只对执行改动的线程可见。
- 防止恶性竞争的另一种方式是通过将修改数据结构及其不变量的设计改变为由一连串不可拆分的改动完成数据变更，称为无锁编程。
- 还有一种防止恶性竞争的方法是将修改数据结构当作事务，类似于数据库在一个事务内完成更新，把需要执行的数据读写操作视为一个完整序列，先用事务日志储存记录，再把序列当成单一步骤提交运行，若别的线程改动了数据而令提交无法完整执行，则事务重新开始，称为软件事务内存（STM）。

### 用互斥保护共享数据

---

- 用互斥保护共享数据，访问一个数据结构前，先锁住与数据相关的互斥，访问结束后在解锁互斥。

- C++ 线程库保证了，一旦有线程锁住了某个互斥，若其他线程试图在给它加锁则需等待，直到最初成功枷锁的线程把该互斥解锁。

- 互斥是 C++ 最通用的共享数据保护措施之一，但非万能的。

- C++ 中通过 `std::mutex` 创建互斥，调用成员函数 `lock` 对其加锁，`unlock` 对其解锁，但并不适合直接使用，C++ 标准库提供了类模板 `std::lock_guard` 针对互斥类融合实现了 RAII 手法：构造加锁，析构解锁。

  ```cpp
  #include <list>
  #include <mutex>
  std::list<int> a_list;
  std::mutex a_mutex;
  void add_to_list(int &new_val) {
      std::lock_guard<std::mutex> a_guard(a_mutex);
      a_list.push_back(new_val);
  }
  ```

- 正常情况下会将互斥与受保护的数据组成一个类。

- 如果成员函数返回受保护数据的指针或者引用，即使锁定互斥也可以访问和修改数据。这种情况只能由程序员自己保证，不得向锁所在的作用域之外传递指针和引用，包括返回值和作为参数传递。

- 